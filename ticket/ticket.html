<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Flippable Ticket</title>
  <style>
    :root {
      --flip-duration: 0.8s;
      --tilt-duration: 0.2s;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: #f0f4f8; /* A soft, neutral background */
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #333;
      overflow: hidden; /* Prevent scrollbars */
      /* Prevent pull-to-refresh and other touch gestures on the body */
      touch-action: none;
    }

    .instructions {
      text-align: center;
      margin-bottom: 2rem;
      padding: 0 1rem;
      max-width: 400px;
    }
    
    #permission-btn {
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 8px;
      border: 1px solid #ccc;
      background-color: #fff;
      margin-bottom: 1rem;
      display: none; /* Hidden by default, shown via JS if needed */
    }

    .ticket-container {
      perspective: 1500px; /* Increased perspective for a more pronounced 3D effect */
      width: 90vw;
      max-width: 350px; /* Slightly smaller for better mobile view */
    }

    .ticket {
      width: 100%;
      /* Aspect ratio for a typical ticket (height/width) */
      padding-top: calc(1539 / 771 * 100%); 
      position: relative;
      transform-style: preserve-3d;
      /* Default transition for smooth tilt */
      transition: transform var(--tilt-duration) linear;
      cursor: grab;
      user-select: none; /* Prevent text selection on the ticket */
    }
    
    .ticket:active {
        cursor: grabbing;
    }

    .ticket-side {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      backface-visibility: hidden; /* Hides the back of the element when flipped */
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .ticket-front {
      background-color: #8E44AD;
    }
    
    /* Shimmer effect for the front side */
    .ticket-front::before {
        content: '';
        position: absolute;
        top: 0;
        left: -80%;
        width: 60%;
        height: 100%;
        background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.25) 50%, rgba(255, 255, 255, 0) 100%);
        transform: skewX(-25deg);
        animation: shimmer 5s infinite cubic-bezier(0.4, 0, 0.6, 1);
        z-index: 1;
    }

    @keyframes shimmer {
      0% {
        left: -80%;
      }
      10% {
        left: 120%;
      }
      100% {
        left: 120%;
      }
    }

    .ticket-back {
      background-color: #2C3E50;
      /* Pre-rotate the back side */
      transform: rotateY(180deg);
    }

    .ticket-side img {
      width: 100%;
      height: 100%;
      /* Ensures the image covers the area without distortion */
      object-fit: cover; 
      display: block;
      pointer-events: none; /* Prevent image from being dragged instead of the ticket */
    }
  </style>

  <!-- âœ… PWA Integration -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#8E44AD">
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("sw.js").catch(console.error);
    }
  </script>
</head>
<body>

  <div class="instructions">
    <h2>Interactive Ticket</h2>
    <p>Tap, or drag/swipe the ticket to flip it. On mobile, tilt your device for a subtle 3D effect.</p>
  </div>
  
  <button id="permission-btn">Enable Tilt Effect</button>

  <div class="ticket-container">
    <div class="ticket" id="ticket">
      <div class="ticket-side ticket-front">
        <img src="SEFront@300x.png" alt="Ticket Front" onerror="this.onerror=null;this.src='https://placehold.co/771x1539/8E44AD/FFFFFF?text=Image+Error';">
      </div>
      <div class="ticket-side ticket-back">
        <img src="SEBack@300x.png" alt="Ticket Back" onerror="this.onerror=null;this.src='https://placehold.co/771x1539/2C3E50/FFFFFF?text=Image+Error';">
      </div>
    </div>
  </div>

<script>
    const ticket = document.getElementById('ticket');
    const permissionBtn = document.getElementById('permission-btn');

    // --- STATE MANAGEMENT ---
    let flipAngle = 0;      // The stable, resting flip angle (a multiple of 180)
    let tiltX = 0;          // Device tilt on X-axis
    let tiltY = 0;          // Device tilt on Y-axis
    let dragAngle = 0;      // Temporary angle from the current drag/swipe
    let spinAngle = 0;      // Temporary angle from the continuous spin animation
    let animationFrameId = null; // To control the animation loop

    // Drag state variables
    let isDragging = false;
    let startX = 0;
    let startTime = 0;

    // --- COMBINED TRANSFORM FUNCTION ---
    const updateTransform = () => {
      // Combines all angles for a single, smooth transform
      const totalYRotation = flipAngle + tiltY + dragAngle + spinAngle;
      ticket.style.transform = `rotateX(${tiltX}deg) rotateY(${totalYRotation}deg)`;
    };

    // --- DRAG/SWIPE LOGIC: START ---
    const onDragStart = (e) => {
      // Cancel any ongoing spin animation when a new drag starts
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        // Settle the ticket immediately
        flipAngle = Math.round((flipAngle + spinAngle) / 180) * 180;
        spinAngle = 0;
        updateTransform();
      }

      isDragging = true;
      startX = e.clientX || e.touches[0].clientX;
      startTime = Date.now();
      ticket.style.transition = 'none'; // Remove transition for direct control
      if (e.type === 'touchstart') e.preventDefault();
    };

    // --- DRAG/SWIPE LOGIC: MOVE ---
    const onDragMove = (e) => {
      if (!isDragging) return;
      const currentX = e.clientX || e.touches[0].clientX;
      const deltaX = currentX - startX;
      dragAngle = (deltaX / ticket.offsetWidth) * 180; // Map drag distance to rotation
      updateTransform();
    };

    // --- DRAG/SWIPE LOGIC: END ---
    const onDragEnd = (e) => {
      if (!isDragging) return;
      isDragging = false;

      const deltaTime = Date.now() - startTime;
      const endX = e.clientX || e.changedTouches[0].clientX;
      const deltaX = endX - startX;
      const velocity = Math.abs(deltaX / deltaTime);

      // --- TAP VS. SWIPE DETERMINATION ---
      if (Math.abs(deltaX) < 10 && deltaTime < 200) {
        flipAngle = (flipAngle === 180) ? 0 : 180;
        dragAngle = 0;
        ticket.style.transition = `transform ${getComputedStyle(document.documentElement).getPropertyValue('--flip-duration')} cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
        updateTransform();
      } else {
        // --- HANDLE SWIPE FOR CONTINUOUS SPIN ---
        flipAngle += dragAngle; // Commit the dragged angle
        dragAngle = 0;

        // Calculate animation parameters based on swipe velocity
        const spinSpeed = Math.max(360, 360 + velocity * 720); // deg/sec
        const spinDuration = Math.max(500, 500 + velocity * 1000); // ms
        const direction = deltaX > 0 ? 1 : -1;

        startSpinAnimation(spinSpeed, spinDuration, direction);
      }
    };

    // --- CONTINUOUS SPIN ANIMATION ---
    const startSpinAnimation = (speed, duration, direction) => {
        let animationStartTime = null;

        const animateSpin = (timestamp) => {
            if (!animationStartTime) animationStartTime = timestamp;
            const elapsedTime = timestamp - animationStartTime;

            if (elapsedTime >= duration) {
                // Animation finished: Settle the ticket
                flipAngle += spinAngle; // Add the total spun angle
                spinAngle = 0; // Reset spin angle
                flipAngle = Math.round(flipAngle / 180) * 180; // Snap to nearest 180 degrees
                updateTransform();
                ticket.style.transition = `transform ${getComputedStyle(document.documentElement).getPropertyValue('--tilt-duration')} linear`;
                return;
            }

            // Calculate current spin angle based on elapsed time
            spinAngle = (elapsedTime / 1000) * speed * direction;
            updateTransform();

            animationFrameId = requestAnimationFrame(animateSpin);
        };
        animationFrameId = requestAnimationFrame(animateSpin);
    };

    // Add event listeners for both mouse and touch
    ticket.addEventListener('mousedown', onDragStart);
    window.addEventListener('mousemove', onDragMove);
    window.addEventListener('mouseup', onDragEnd);
    window.addEventListener('mouseleave', onDragEnd);

    ticket.addEventListener('touchstart', onDragStart, { passive: false });
    window.addEventListener('touchmove', onDragMove, { passive: true });
    window.addEventListener('touchend', onDragEnd);
    window.addEventListener('touchcancel', onDragEnd);

    // --- DEVICE TILT LOGIC ---
    const handleOrientation = (event) => {
      const beta = event.beta;
      const gamma = event.gamma;
      if (beta === null || gamma === null) return;
      tiltX = Math.max(-15, Math.min(15, beta));
      tiltY = Math.max(-15, Math.min(15, gamma));
      if (!isDragging) {
        updateTransform();
      }
    };

    // --- PERMISSION & EVENT LISTENER SETUP ---
    if (window.DeviceOrientationEvent) {
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        permissionBtn.style.display = 'block';
        permissionBtn.addEventListener('click', () => {
          DeviceOrientationEvent.requestPermission()
            .then(response => {
              if (response === 'granted') {
                window.addEventListener('deviceorientation', handleOrientation);
                permissionBtn.style.display = 'none';
              } else {
                alert('Permission not granted. Tilt effect will not work.');
              }
            }).catch(console.error);
        });
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
      }
    }
</script>

</body>
</html>
